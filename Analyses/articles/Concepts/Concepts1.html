<link rel="stylesheet" href="../../article.css">

<div class="articlemain">
<div class="article">
<p>Concepts1 - TTC0RE<br />&mdash; writing<br /><br /><br />This is a list of concepts, their meaning, usefulness, and implementation.<br /><br /><br />&mdash;defensive design&mdash;<br />This is a concept first written in my system fundamentals note.<br /><br />Defensive design means instead of exception, all operations are dependent on a set number of variables.<br /><br />So instead of worrying about the countless variables that could wreck a operation,<br />Quota the necessary status of operations, or states, (variables) that are needed to complete the operation.<br /><br />The tighter such a system works, <br />Or rather,<br />The more and well thought out the neccesary variables are, the higher stability the system becomes.<br /><br />[ -example<br />Let us say a operation needs 3 state variables (variable 1, variable2, variable 3) from relevant areas of a system for a function to work (known as a protocol),<br /><br />Instead of simply saying,<br />&ldquo;These 3 work, then it should work&rdquo;, (is correct)<br /><br />If we go deeper and quantify the state of those 3 variables being the correct one,<br />For instance.<br /><br />&ldquo;Variable 1 needs v1a and v1b to be correct&rdquo;,<br />And &ldquo;Variable 2 needs variable 1 and v1b to be correct&rdquo;<br /><br />We can quantify the things needed to make sure a system works, by establishing the variables that all affect the system/protocol,<br /><br />Thus, stability is increased,<br />Why?<br />Because establishing a system that relates to each other correctly, allows us to build it &lsquo;tighter&rsquo;, and possibly that there would be no outside variables that cannot be controlled.<br /><br />It allows us to have better control of the variables, thus increasing stability and efficiency.<br />] -/example<br /><br /><br />&mdash;offensive defensive<br />Similar concept,<br />That you build towards things you need, instead of things you cant control.<br /><br />Learning to do &lsquo;with&rsquo; and not &lsquo;without&rsquo;.<br /><br />Thus, offensive defensive.<br /><br />You can have a super tight offense that is &lsquo;defensive&rsquo; thanks to such a concept,<br />That you can work at peak efficiency since your offense is based upon a closed system, thus defensive.<br /><br />A defensive system, a stable one, not open to outside attack or &lsquo;variables&rsquo;, allows it to work tighter.<br /><br />And since the offensive is based upon the defensive system, its effectiveness is based upon the efficiency or effectiveness of the defensive system,<br /><br />And since it is &lsquo;defensive&rsquo; it is under your control,<br />Or rather, you have more control over it, allowing it to better handle &lsquo;uncaught exemptions&rsquo;, variables, or attacks (depending on context).<br /><br />Thus effectiveness (offense) based upon self-sufficiency (defense)<br />&mdash;/offensive defense<br /><br /><br /><br />&mdash;redundancy&mdash;<br />Redundancy, a popular word in systems relating to stability.<br /><br />Redundancy basically means (in my personal interpreted form),<br />Shared, or backup &lsquo;state&rsquo; so that when something corrupts you have correct &lsquo;state&rsquo; accessible to restore system information, variables, or &lsquo;state&rsquo;.<br /><br />&mdash;<br /><br />Here is my opinion.<br /><br />Redundancy breeds inefficiency.<br /><br />&mdash;<br /><br />Why?<br />Backups are not wrong,<br />And they should most definitely be a protocol in a system,<br />But building a system based upon protocols for redundancy,<br />(Redundant protocols (XD)),<br /><br />Make the system complicated, and instead of having many backups,<br />You have many opportunities for things to go awry,<br /><br />If a single slipup happens in a redundancy protocol, the redundant copies can become corrupted, and thus scouring the system for the correct redundancy, and the incorrect ones.<br /><br />And of course, since it is possible a &lsquo;redudantly based system&rsquo; will use either a read or write for the redundancy protocol, its possible to be pulling corrupt redundant states and corrupting a &lsquo;retrieval of a backup&rsquo;.<br /><br />So having in &lsquo;state&rsquo; of a system possible mix-ups of correct and corrupted redundancy makes it difficult to find, fix, and generally take extra time to accomplish protocols, or functions of the system.<br /><br />Even the making of redundant information takes time.<br /><br />And even a way a system calls for information,<br />Should it always call for the redundant copy?<br /><br />(<br />Since a redundant is usually made in-case a protocol fails, or in a change.<br />Like backup up a file before changing it, in-case it breaks<br />)<br /><br />And this the dilemma,<br /><br />You could have redundant everywhere,<br />Eventually have a practically duplicate system inside itself,<br />Taking twice the space, and perhaps using half/twice the time! (Read and writes of redundant copies of each systems/written variable, operation, operation-result, etc...)<br /><br />[<br />Basically, when a system accomplishes a result, it writes result to the next part of the protocol (obviously, it does the system) and then writes same thing to the redundant area/part of system<br /><br />Thus 2 writes for a single result. (Or maybe more! Like a &lsquo;before&rsquo; and &lsquo;after&rsquo; state of a simple completed operation in-case the variable changes the protocol itself (self-referring change))<br />]<br /><br />&mdash;<br /><br />So a balance is needed, or rather, a better design.<br /><br />&mdash;<br /><br />Windows, btw, is notorious for their confusing, and often unstable &lsquo;stable=goal&rsquo; or redundancy protocols.<br />(IE: backup windows version, drivers, etc...)<br /><br /><br />&mdash;TTC0RE&rsquo;s Redundant Design<br />In this case, i am going to be desiging a operating system, and i will be contrasting (&lsquo;interpreted&rsquo; windows features, OSX, etc...)<br /><br />Imho,<br />Redundancy should only be created once,<br />And that everything should be modular.<br /><br />The redundancy &lsquo;area&rsquo; or &lsquo;system&rsquo;, &lsquo;application&rsquo;, or &lsquo;environment&rsquo; should be unbiased and set apart from the system.<br /><br />(<br />Difference in having something built in, and another to have it linked by linked integration<br />-<br />Or rather.<br /><br />A application doesn&rsquo;t use a redundancy protocol into itself or under its umbrella (in its protocl, resoucrs, or environment), it writes it to the separate area/environment.<br />)<br /><br />So.<br /><br />A system level 2 integration, so that it works on the actual &lsquo;implementation&rsquo; api,<br /><br />Or rather, its a service all applications can invoke and use integrated into theirnworkflows.<br /><br />So that a application will write to its designated folder in its redundancy.<br /><br />-redundancy environment/protocol<br /><br /></p>

</div></div>